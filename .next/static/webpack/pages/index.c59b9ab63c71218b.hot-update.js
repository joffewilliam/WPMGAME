"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/ResultsGraph.tsx":
/*!*************************************!*\
  !*** ./components/ResultsGraph.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * ResultsGraph Component\r\n * \r\n * Renders a canvas-based performance graph showing:\r\n * - WPM over time\r\n * - Accuracy percentage over time\r\n * - Error indicators\r\n * - Supports both light and dark themes\r\n */ \nvar _s = $RefreshSig$();\n\nconst ResultsGraph = (param)=>{\n    let { data, width = 900, height = 300, theme = 'dark' } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle edge cases with minimal data\n    if (!data || data.length <= 1) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center justify-center text-gray-500 mx-auto rounded-md\",\n            style: {\n                '--graph-width': \"\".concat(width, \"px\"),\n                '--graph-height': \"\".concat(height, \"px\")\n            },\n            \"data-width\": width,\n            \"data-height\": height,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Insufficient data to display graph\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n                lineNumber: 38,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n            lineNumber: 32,\n            columnNumber: 7\n        }, undefined);\n    }\n    // Ensure maxSeconds is set based on actual data\n    const maxSeconds = Math.max(...data.map((point)=>point.second));\n    const maxWPM = Math.max(100, Math.max(...data.map((point)=>point.wpm)));\n    const maxErrors = Math.max(...data.map((point)=>point.errors), 5);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResultsGraph.useEffect\": ()=>{\n            if (!canvasRef.current || data.length === 0) return;\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            // Add padding to prevent cutting off labels\n            const padding = {\n                left: 40,\n                right: 40,\n                top: 20,\n                bottom: 25 // Bottom padding for time labels\n            };\n            // Adjusted drawing area\n            const drawWidth = width - padding.left - padding.right;\n            const drawHeight = height - padding.top - padding.bottom;\n            // Set up canvas\n            ctx.clearRect(0, 0, width, height);\n            // Background color based on theme\n            if (theme === 'dark') {\n                ctx.fillStyle = '#1e293b'; // Dark background\n            } else {\n                ctx.fillStyle = '#f8fafc'; // Light background\n            }\n            ctx.fillRect(0, 0, width, height);\n            // Draw chart title\n            const titleColor = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillStyle = titleColor;\n            ctx.font = 'bold 14px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText('Performance Over Time', width / 2, padding.top / 2 + 5);\n            // Draw legend at the top of the graph, below the title\n            const legendY = padding.top / 2 + 20;\n            const legendX = width / 2 - 120; // Center the legend\n            // WPM legend item\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e';\n            ctx.beginPath();\n            ctx.moveTo(legendX, legendY);\n            ctx.lineTo(legendX + 20, legendY);\n            ctx.stroke();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.textAlign = 'left';\n            ctx.fillText('WPM', legendX + 25, legendY + 4);\n            // Accuracy legend item\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6';\n            ctx.beginPath();\n            ctx.moveTo(legendX + 80, legendY);\n            ctx.lineTo(legendX + 100, legendY);\n            ctx.stroke();\n            ctx.fillText('Accuracy', legendX + 105, legendY + 4);\n            // Error legend item\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626';\n            ctx.beginPath();\n            ctx.arc(legendX + 190, legendY, 4, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillText('Errors', legendX + 200, legendY + 4);\n            // Draw grid\n            ctx.strokeStyle = theme === 'dark' ? '#334155' : '#cbd5e1'; // Grid lines\n            ctx.lineWidth = 1;\n            // Draw y-axis labels for WPM (left side)\n            const wpmStep = Math.ceil(maxWPM / 4);\n            for(let i = 0; i <= 4; i++){\n                const wpmValue = i * wpmStep;\n                const y = padding.top + drawHeight - wpmValue / maxWPM * drawHeight;\n                // Draw horizontal grid line\n                ctx.beginPath();\n                ctx.moveTo(padding.left, y);\n                ctx.lineTo(padding.left + drawWidth, y);\n                ctx.stroke();\n                // Draw WPM label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.font = '11px sans-serif';\n                ctx.textAlign = 'right';\n                ctx.fillText(\"\".concat(wpmValue), padding.left - 5, y + 4);\n            }\n            // Draw y-axis labels for Accuracy (right side)\n            for(let i = 0; i <= 4; i++){\n                const accuracyValue = i * 25; // 0, 25, 50, 75, 100\n                const y = padding.top + drawHeight - accuracyValue / 100 * drawHeight;\n                // Accuracy label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'left';\n                ctx.fillText(\"\".concat(accuracyValue, \"%\"), padding.left + drawWidth + 5, y + 4);\n            }\n            // Draw x-axis (time) labels and vertical grid lines\n            const timeInterval = maxSeconds <= 15 ? 5 : maxSeconds <= 30 ? 10 : 15;\n            for(let i = 0; i <= maxSeconds; i += timeInterval){\n                const x = padding.left + i / maxSeconds * drawWidth;\n                // Draw vertical grid line\n                ctx.beginPath();\n                ctx.moveTo(x, padding.top);\n                ctx.lineTo(x, padding.top + drawHeight);\n                ctx.stroke();\n                // Draw time label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(i, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw final time marker if not included in intervals\n            if (maxSeconds % timeInterval !== 0) {\n                const x = padding.left + drawWidth;\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(maxSeconds, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw WPM line\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e'; // Green line for WPM\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw errors as red dots\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626'; // Red for errors\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point)=>{\n                    if (point.errors > 0) {\n                        const x = padding.left + point.second / maxSeconds * drawWidth;\n                        const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                        ctx.beginPath();\n                        ctx.arc(x, y, 4, 0, 2 * Math.PI);\n                        ctx.fill();\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            // Draw accuracy line\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6'; // Blue line for accuracy\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.accuracy / 100 * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw axis labels\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.font = 'bold 12px sans-serif';\n            // WPM label\n            ctx.textAlign = 'center';\n            ctx.save();\n            ctx.translate(15, padding.top + drawHeight / 2);\n            ctx.rotate(-Math.PI / 2);\n            ctx.fillText('WPM', 0, 0);\n            ctx.restore();\n            // Accuracy label\n            ctx.save();\n            ctx.translate(width - 15, padding.top + drawHeight / 2);\n            ctx.rotate(Math.PI / 2);\n            ctx.fillText('Accuracy', 0, 0);\n            ctx.restore();\n            // Time label\n            ctx.textAlign = 'center';\n            ctx.fillText('Time (seconds)', padding.left + drawWidth / 2, height - 5);\n        }\n    }[\"ResultsGraph.useEffect\"], [\n        data,\n        width,\n        height,\n        maxWPM,\n        maxErrors,\n        theme,\n        maxSeconds\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        className: \"rounded-md mx-auto\"\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n        lineNumber: 244,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ResultsGraph, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = ResultsGraph;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ResultsGraph);\nvar _c;\n$RefreshReg$(_c, \"ResultsGraph\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvUmVzdWx0c0dyYXBoLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDOztBQUNnRDtBQWdCakQsTUFBTUcsZUFBNEM7UUFBQyxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsR0FBRyxFQUFFQyxTQUFTLEdBQUcsRUFBRUMsUUFBUSxNQUFNLEVBQUU7O0lBQ3BHLE1BQU1DLFlBQVlOLDZDQUFNQSxDQUFvQjtJQUU1QyxzQ0FBc0M7SUFDdEMsSUFBSSxDQUFDRSxRQUFRQSxLQUFLSyxNQUFNLElBQUksR0FBRztRQUM3QixxQkFDRSw4REFBQ0M7WUFDQ0MsV0FBVTtZQUNWQyxPQUFPO2dCQUFFLGlCQUFpQixHQUFTLE9BQU5QLE9BQU07Z0JBQUssa0JBQWtCLEdBQVUsT0FBUEMsUUFBTztZQUFJO1lBQ3hFTyxjQUFZUjtZQUNaUyxlQUFhUjtzQkFFYiw0RUFBQ1M7MEJBQUU7Ozs7Ozs7Ozs7O0lBR1Q7SUFFQSxnREFBZ0Q7SUFDaEQsTUFBTUMsYUFBYUMsS0FBS0MsR0FBRyxJQUFJZCxLQUFLZSxHQUFHLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLE1BQU07SUFDN0QsTUFBTUMsU0FBU0wsS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtDLEdBQUcsSUFBSWQsS0FBS2UsR0FBRyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNRyxHQUFHO0lBQ3BFLE1BQU1DLFlBQVlQLEtBQUtDLEdBQUcsSUFBSWQsS0FBS2UsR0FBRyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNSyxNQUFNLEdBQUc7SUFFL0R4QixnREFBU0E7a0NBQUM7WUFDUixJQUFJLENBQUNPLFVBQVVrQixPQUFPLElBQUl0QixLQUFLSyxNQUFNLEtBQUssR0FBRztZQUU3QyxNQUFNa0IsU0FBU25CLFVBQVVrQixPQUFPO1lBQ2hDLE1BQU1FLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztZQUM5QixJQUFJLENBQUNELEtBQUs7WUFFViw0Q0FBNEM7WUFD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QU8sR0FBRztZQUN2QmYsSUFBSXlDLE9BQU87WUFFWCxpQkFBaUI7WUFDakJ6QyxJQUFJc0MsSUFBSTtZQUNSdEMsSUFBSXVDLFNBQVMsQ0FBQzlELFFBQVEsSUFBSXlCLFFBQVFHLEdBQUcsR0FBR0csYUFBYTtZQUNyRFIsSUFBSXdDLE1BQU0sQ0FBQ25ELEtBQUttQyxFQUFFLEdBQUc7WUFDckJ4QixJQUFJZSxRQUFRLENBQUMsWUFBWSxHQUFHO1lBQzVCZixJQUFJeUMsT0FBTztZQUVYLGFBQWE7WUFDYnpDLElBQUljLFNBQVMsR0FBRztZQUNoQmQsSUFBSWUsUUFBUSxDQUFDLGtCQUFrQmIsUUFBUUMsSUFBSSxHQUFHSSxZQUFZLEdBQUc3QixTQUFTO1FBRXhFO2lDQUFHO1FBQUNGO1FBQU1DO1FBQU9DO1FBQVFnQjtRQUFRRTtRQUFXakI7UUFBT1M7S0FBVztJQUU5RCxxQkFDRSw4REFBQ1c7UUFDQzJDLEtBQUs5RDtRQUNMSCxPQUFPQTtRQUNQQyxRQUFRQTtRQUNSSyxXQUFVOzs7Ozs7QUFHaEI7R0FqT01SO0tBQUFBO0FBbU9OLGlFQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRyYWdnXFxPbmVEcml2ZVxcRGVza3RvcFxcV1BNR0FNRVxcY29tcG9uZW50c1xcUmVzdWx0c0dyYXBoLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUmVzdWx0c0dyYXBoIENvbXBvbmVudFxyXG4gKiBcclxuICogUmVuZGVycyBhIGNhbnZhcy1iYXNlZCBwZXJmb3JtYW5jZSBncmFwaCBzaG93aW5nOlxyXG4gKiAtIFdQTSBvdmVyIHRpbWVcclxuICogLSBBY2N1cmFjeSBwZXJjZW50YWdlIG92ZXIgdGltZVxyXG4gKiAtIEVycm9yIGluZGljYXRvcnNcclxuICogLSBTdXBwb3J0cyBib3RoIGxpZ2h0IGFuZCBkYXJrIHRoZW1lc1xyXG4gKi9cclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxudHlwZSBEYXRhUG9pbnQgPSB7XHJcbiAgc2Vjb25kOiBudW1iZXI7XHJcbiAgd3BtOiBudW1iZXI7XHJcbiAgYWNjdXJhY3k6IG51bWJlcjtcclxuICBlcnJvcnM6IG51bWJlcjtcclxufTtcclxuXHJcbnR5cGUgUmVzdWx0c0dyYXBoUHJvcHMgPSB7XHJcbiAgZGF0YTogRGF0YVBvaW50W107XHJcbiAgd2lkdGg/OiBudW1iZXI7XHJcbiAgaGVpZ2h0PzogbnVtYmVyO1xyXG4gIHRoZW1lPzogJ2xpZ2h0JyB8ICdkYXJrJztcclxufTtcclxuXHJcbmNvbnN0IFJlc3VsdHNHcmFwaDogUmVhY3QuRkM8UmVzdWx0c0dyYXBoUHJvcHM+ID0gKHsgZGF0YSwgd2lkdGggPSA5MDAsIGhlaWdodCA9IDMwMCwgdGhlbWUgPSAnZGFyaycgfSkgPT4ge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcblxyXG4gIC8vIEhhbmRsZSBlZGdlIGNhc2VzIHdpdGggbWluaW1hbCBkYXRhXHJcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoIDw9IDEpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXYgXHJcbiAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC1ncmF5LTUwMCBteC1hdXRvIHJvdW5kZWQtbWRcIlxyXG4gICAgICAgIHN0eWxlPXt7ICctLWdyYXBoLXdpZHRoJzogYCR7d2lkdGh9cHhgLCAnLS1ncmFwaC1oZWlnaHQnOiBgJHtoZWlnaHR9cHhgIH0gYXMgUmVhY3QuQ1NTUHJvcGVydGllc31cclxuICAgICAgICBkYXRhLXdpZHRoPXt3aWR0aH1cclxuICAgICAgICBkYXRhLWhlaWdodD17aGVpZ2h0fVxyXG4gICAgICA+XHJcbiAgICAgICAgPHA+SW5zdWZmaWNpZW50IGRhdGEgdG8gZGlzcGxheSBncmFwaDwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIG1heFNlY29uZHMgaXMgc2V0IGJhc2VkIG9uIGFjdHVhbCBkYXRhXHJcbiAgY29uc3QgbWF4U2Vjb25kcyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LnNlY29uZCkpO1xyXG4gIGNvbnN0IG1heFdQTSA9IE1hdGgubWF4KDEwMCwgTWF0aC5tYXgoLi4uZGF0YS5tYXAocG9pbnQgPT4gcG9pbnQud3BtKSkpO1xyXG4gIGNvbnN0IG1heEVycm9ycyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LmVycm9ycyksIDUpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEFkZCBwYWRkaW5nIHRvIHByZXZlbnQgY3V0dGluZyBvZmYgbGFiZWxzXHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICBsZWZ0OiA0MCwgIC8vIExlZnQgcGFkZGluZyBmb3IgV1BNIGxhYmVsc1xyXG4gICAgICByaWdodDogNDAsIC8vIFJpZ2h0IHBhZGRpbmcgZm9yIEFjY3VyYWN5IGxhYmVsc1xyXG4gICAgICB0b3A6IDIwLCAgIC8vIFRvcCBwYWRkaW5nIFxyXG4gICAgICBib3R0b206IDI1IC8vIEJvdHRvbSBwYWRkaW5nIGZvciB0aW1lIGxhYmVsc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGp1c3RlZCBkcmF3aW5nIGFyZWFcclxuICAgIGNvbnN0IGRyYXdXaWR0aCA9IHdpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcclxuICAgIGNvbnN0IGRyYXdIZWlnaHQgPSBoZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgIC8vIFNldCB1cCBjYW52YXNcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gQmFja2dyb3VuZCBjb2xvciBiYXNlZCBvbiB0aGVtZVxyXG4gICAgaWYgKHRoZW1lID09PSAnZGFyaycpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMWUyOTNiJzsgLy8gRGFyayBiYWNrZ3JvdW5kXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNmOGZhZmMnOyAvLyBMaWdodCBiYWNrZ3JvdW5kXHJcbiAgICB9XHJcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gRHJhdyBjaGFydCB0aXRsZVxyXG4gICAgY29uc3QgdGl0bGVDb2xvciA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVDb2xvcjtcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTRweCBzYW5zLXNlcmlmJztcclxuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgIGN0eC5maWxsVGV4dCgnUGVyZm9ybWFuY2UgT3ZlciBUaW1lJywgd2lkdGggLyAyLCBwYWRkaW5nLnRvcCAvIDIgKyA1KTtcclxuXHJcbiAgICAvLyBEcmF3IGxlZ2VuZCBhdCB0aGUgdG9wIG9mIHRoZSBncmFwaCwgYmVsb3cgdGhlIHRpdGxlXHJcbiAgICBjb25zdCBsZWdlbmRZID0gcGFkZGluZy50b3AgLyAyICsgMjA7XHJcbiAgICBjb25zdCBsZWdlbmRYID0gd2lkdGggLyAyIC0gMTIwOyAvLyBDZW50ZXIgdGhlIGxlZ2VuZFxyXG4gICAgXHJcbiAgICAvLyBXUE0gbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzRhZGU4MCcgOiAnIzIyYzU1ZSc7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFgsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LmxpbmVUbyhsZWdlbmRYICsgMjAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdXUE0nLCBsZWdlbmRYICsgMjUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFggKyA4MCwgbGVnZW5kWSk7XHJcbiAgICBjdHgubGluZVRvKGxlZ2VuZFggKyAxMDAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdBY2N1cmFjeScsIGxlZ2VuZFggKyAxMDUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gRXJyb3IgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyNlZjQ0NDQnIDogJyNkYzI2MjYnO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyhsZWdlbmRYICsgMTkwLCBsZWdlbmRZLCA0LCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFRleHQoJ0Vycm9ycycsIGxlZ2VuZFggKyAyMDAsIGxlZ2VuZFkgKyA0KTtcclxuXHJcbiAgICAvLyBEcmF3IGdyaWRcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzMzNDE1NScgOiAnI2NiZDVlMSc7IC8vIEdyaWQgbGluZXNcclxuICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgV1BNIChsZWZ0IHNpZGUpXHJcbiAgICBjb25zdCB3cG1TdGVwID0gTWF0aC5jZWlsKG1heFdQTSAvIDQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdwbVZhbHVlID0gaSAqIHdwbVN0ZXA7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAod3BtVmFsdWUgLyBtYXhXUE0pICogZHJhd0hlaWdodDtcclxuICAgICAgXHJcbiAgICAgIC8vIERyYXcgaG9yaXpvbnRhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHBhZGRpbmcubGVmdCwgeSk7XHJcbiAgICAgIGN0eC5saW5lVG8ocGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoLCB5KTtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyBXUE0gbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC5mb250ID0gJzExcHggc2Fucy1zZXJpZic7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICBjdHguZmlsbFRleHQoYCR7d3BtVmFsdWV9YCwgcGFkZGluZy5sZWZ0IC0gNSwgeSArIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgQWNjdXJhY3kgKHJpZ2h0IHNpZGUpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA0OyBpKyspIHtcclxuICAgICAgY29uc3QgYWNjdXJhY3lWYWx1ZSA9IGkgKiAyNTsgLy8gMCwgMjUsIDUwLCA3NSwgMTAwXHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAoYWNjdXJhY3lWYWx1ZSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICBcclxuICAgICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHthY2N1cmFjeVZhbHVlfSVgLCBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGggKyA1LCB5ICsgNCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyB4LWF4aXMgKHRpbWUpIGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgY29uc3QgdGltZUludGVydmFsID0gbWF4U2Vjb25kcyA8PSAxNSA/IDUgOiBtYXhTZWNvbmRzIDw9IDMwID8gMTAgOiAxNTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heFNlY29uZHM7IGkgKz0gdGltZUludGVydmFsKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAoaSAvIG1heFNlY29uZHMpICogZHJhd1dpZHRoO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyB2ZXJ0aWNhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHgsIHBhZGRpbmcudG9wKTtcclxuICAgICAgY3R4LmxpbmVUbyh4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEcmF3IHRpbWUgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgY3R4LmZpbGxUZXh0KGAke2l9c2AsIHgsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCArIDE1KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEcmF3IGZpbmFsIHRpbWUgbWFya2VyIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnRlcnZhbHNcclxuICAgIGlmIChtYXhTZWNvbmRzICUgdGltZUludGVydmFsICE9PSAwKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGg7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyM5NGEzYjgnIDogJyM0NzU1NjknO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHttYXhTZWNvbmRzfXNgLCB4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgKyAxNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBXUE0gbGluZVxyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjNGFkZTgwJyA6ICcjMjJjNTVlJzsgLy8gR3JlZW4gbGluZSBmb3IgV1BNXHJcbiAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGRhdGEuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAocG9pbnQuc2Vjb25kIC8gbWF4U2Vjb25kcykgKiBkcmF3V2lkdGg7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAocG9pbnQud3BtIC8gbWF4V1BNKSAqIGRyYXdIZWlnaHQ7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcclxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgIC8vIERyYXcgZXJyb3JzIGFzIHJlZCBkb3RzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZWY0NDQ0JyA6ICcjZGMyNjI2JzsgLy8gUmVkIGZvciBlcnJvcnNcclxuICAgIGRhdGEuZm9yRWFjaChwb2ludCA9PiB7XHJcbiAgICAgIGlmIChwb2ludC5lcnJvcnMgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgICBjb25zdCB5ID0gcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC0gKHBvaW50LndwbSAvIG1heFdQTSkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHgsIHksIDQsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEcmF3IGFjY3VyYWN5IGxpbmVcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7IC8vIEJsdWUgbGluZSBmb3IgYWNjdXJhY3lcclxuICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgZGF0YS5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgY29uc3QgeSA9IHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAtIChwb2ludC5hY2N1cmFjeSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG5cclxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAvLyBEcmF3IGF4aXMgbGFiZWxzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZjhmYWZjJyA6ICcjMWUyOTNiJztcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTJweCBzYW5zLXNlcmlmJztcclxuICAgIFxyXG4gICAgLy8gV1BNIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSgxNSwgcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC8gMik7XHJcbiAgICBjdHgucm90YXRlKC1NYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ1dQTScsIDAsIDApO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gMTUsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAvIDIpO1xyXG4gICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ0FjY3VyYWN5JywgMCwgMCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBUaW1lIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguZmlsbFRleHQoJ1RpbWUgKHNlY29uZHMpJywgcGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoIC8gMiwgaGVpZ2h0IC0gNSk7XHJcblxyXG4gIH0sIFtkYXRhLCB3aWR0aCwgaGVpZ2h0LCBtYXhXUE0sIG1heEVycm9ycywgdGhlbWUsIG1heFNlY29uZHNdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxjYW52YXMgXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfSBcclxuICAgICAgd2lkdGg9e3dpZHRofSBcclxuICAgICAgaGVpZ2h0PXtoZWlnaHR9IFxyXG4gICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLW1kIG14LWF1dG9cIlxyXG4gICAgLz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVzdWx0c0dyYXBoO1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJSZXN1bHRzR3JhcGgiLCJkYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJ0aGVtZSIsImNhbnZhc1JlZiIsImxlbmd0aCIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwiZGF0YS13aWR0aCIsImRhdGEtaGVpZ2h0IiwicCIsIm1heFNlY29uZHMiLCJNYXRoIiwibWF4IiwibWFwIiwicG9pbnQiLCJzZWNvbmQiLCJtYXhXUE0iLCJ3cG0iLCJtYXhFcnJvcnMiLCJlcnJvcnMiLCJjdXJyZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsInBhZGRpbmciLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJkcmF3V2lkdGgiLCJkcmF3SGVpZ2h0IiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0aXRsZUNvbG9yIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwibGVnZW5kWSIsImxlZ2VuZFgiLCJzdHJva2VTdHlsZSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImFyYyIsIlBJIiwiZmlsbCIsImxpbmVXaWR0aCIsIndwbVN0ZXAiLCJjZWlsIiwiaSIsIndwbVZhbHVlIiwieSIsImFjY3VyYWN5VmFsdWUiLCJ0aW1lSW50ZXJ2YWwiLCJ4IiwiZm9yRWFjaCIsImluZGV4IiwiYWNjdXJhY3kiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVzdG9yZSIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/ResultsGraph.tsx\n"));

/***/ })

});