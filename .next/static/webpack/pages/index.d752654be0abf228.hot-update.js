"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/ResultsGraph.tsx":
/*!*************************************!*\
  !*** ./components/ResultsGraph.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst ResultsGraph = (param)=>{\n    let { data, width = 900, height = 300, theme = 'dark' } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle edge cases with minimal data\n    if (!data || data.length <= 1) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width,\n                height\n            },\n            className: \"flex items-center justify-center text-gray-500\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Insufficient data to display graph\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n                lineNumber: 27,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n            lineNumber: 23,\n            columnNumber: 7\n        }, undefined);\n    }\n    // Ensure maxSeconds is set based on actual data\n    const maxSeconds = Math.max(...data.map((point)=>point.second));\n    const maxWPM = Math.max(100, Math.max(...data.map((point)=>point.wpm)));\n    const maxErrors = Math.max(...data.map((point)=>point.errors), 5);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResultsGraph.useEffect\": ()=>{\n            if (!canvasRef.current || data.length === 0) return;\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            // Add padding to prevent cutting off labels\n            const padding = {\n                left: 40,\n                right: 40,\n                top: 20,\n                bottom: 25 // Bottom padding for time labels\n            };\n            // Adjusted drawing area\n            const drawWidth = width - padding.left - padding.right;\n            const drawHeight = height - padding.top - padding.bottom;\n            // Set up canvas\n            ctx.clearRect(0, 0, width, height);\n            // Background color based on theme\n            if (theme === 'dark') {\n                ctx.fillStyle = '#1e293b'; // Dark background\n            } else {\n                ctx.fillStyle = '#f8fafc'; // Light background\n            }\n            ctx.fillRect(0, 0, width, height);\n            // Draw chart title\n            const titleColor = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillStyle = titleColor;\n            ctx.font = 'bold 14px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText('Performance Over Time', width / 2, padding.top / 2 + 5);\n            // Draw grid\n            ctx.strokeStyle = theme === 'dark' ? '#334155' : '#cbd5e1'; // Grid lines\n            ctx.lineWidth = 1;\n            // Draw y-axis labels for WPM (left side)\n            const wpmStep = Math.ceil(maxWPM / 4);\n            for(let i = 0; i <= 4; i++){\n                const wpmValue = i * wpmStep;\n                const y = padding.top + drawHeight - wpmValue / maxWPM * drawHeight;\n                // Draw horizontal grid line\n                ctx.beginPath();\n                ctx.moveTo(padding.left, y);\n                ctx.lineTo(padding.left + drawWidth, y);\n                ctx.stroke();\n                // Draw WPM label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.font = '11px sans-serif';\n                ctx.textAlign = 'right';\n                ctx.fillText(\"\".concat(wpmValue), padding.left - 5, y + 4);\n            }\n            // Draw y-axis labels for Accuracy (right side)\n            for(let i = 0; i <= 4; i++){\n                const accuracyValue = i * 25; // 0, 25, 50, 75, 100\n                const y = padding.top + drawHeight - accuracyValue / 100 * drawHeight;\n                // Accuracy label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'left';\n                ctx.fillText(\"\".concat(accuracyValue, \"%\"), padding.left + drawWidth + 5, y + 4);\n            }\n            // Draw x-axis (time) labels and vertical grid lines\n            const timeInterval = maxSeconds <= 15 ? 5 : maxSeconds <= 30 ? 10 : 15;\n            for(let i = 0; i <= maxSeconds; i += timeInterval){\n                const x = padding.left + i / maxSeconds * drawWidth;\n                // Draw vertical grid line\n                ctx.beginPath();\n                ctx.moveTo(x, padding.top);\n                ctx.lineTo(x, padding.top + drawHeight);\n                ctx.stroke();\n                // Draw time label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(i, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw final time marker if not included in intervals\n            if (maxSeconds % timeInterval !== 0) {\n                const x = padding.left + drawWidth;\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(maxSeconds, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw WPM line\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e'; // Green line for WPM\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw errors as red dots\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626'; // Red for errors\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point)=>{\n                    if (point.errors > 0) {\n                        const x = padding.left + point.second / maxSeconds * drawWidth;\n                        const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                        ctx.beginPath();\n                        ctx.arc(x, y, 4, 0, 2 * Math.PI);\n                        ctx.fill();\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            // Draw accuracy line\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6'; // Blue line for accuracy\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.accuracy / 100 * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw axis labels\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.font = 'bold 12px sans-serif';\n            // WPM label\n            ctx.textAlign = 'center';\n            ctx.save();\n            ctx.translate(15, padding.top + drawHeight / 2);\n            ctx.rotate(-Math.PI / 2);\n            ctx.fillText('WPM', 0, 0);\n            ctx.restore();\n            // Accuracy label\n            ctx.save();\n            ctx.translate(width - 15, padding.top + drawHeight / 2);\n            ctx.rotate(Math.PI / 2);\n            ctx.fillText('Accuracy', 0, 0);\n            ctx.restore();\n            // Time label\n            ctx.textAlign = 'center';\n            ctx.fillText('Time (seconds)', padding.left + drawWidth / 2, height - 5);\n            // Draw legend\n            const legendX = padding.left + 10;\n            const legendY = padding.top + 15;\n            // WPM legend item\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e';\n            ctx.beginPath();\n            ctx.moveTo(legendX, legendY);\n            ctx.lineTo(legendX + 20, legendY);\n            ctx.stroke();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.textAlign = 'left';\n            ctx.fillText('WPM', legendX + 25, legendY + 4);\n            // Accuracy legend item\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6';\n            ctx.beginPath();\n            ctx.moveTo(legendX + 80, legendY);\n            ctx.lineTo(legendX + 100, legendY);\n            ctx.stroke();\n            ctx.fillText('Accuracy', legendX + 105, legendY + 4);\n            // Error legend item\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626';\n            ctx.beginPath();\n            ctx.arc(legendX + 190, legendY, 4, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillText('Errors', legendX + 200, legendY + 4);\n        }\n    }[\"ResultsGraph.useEffect\"], [\n        data,\n        width,\n        height,\n        maxWPM,\n        maxErrors,\n        theme,\n        maxSeconds\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        className: \"rounded-md mx-auto\"\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n        lineNumber: 233,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ResultsGraph, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = ResultsGraph;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ResultsGraph);\nvar _c;\n$RefreshReg$(_c, \"ResultsGraph\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvUmVzdWx0c0dyYXBoLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlEO0FBZ0JqRCxNQUFNRyxlQUE0QztRQUFDLEVBQUVDLElBQUksRUFBRUMsUUFBUSxHQUFHLEVBQUVDLFNBQVMsR0FBRyxFQUFFQyxRQUFRLE1BQU0sRUFBRTs7SUFDcEcsTUFBTUMsWUFBWU4sNkNBQU1BLENBQW9CO0lBRTVDLHNDQUFzQztJQUN0QyxJQUFJLENBQUNFLFFBQVFBLEtBQUtLLE1BQU0sSUFBSSxHQUFHO1FBQzdCLHFCQUNFLDhEQUFDQztZQUNDQyxPQUFPO2dCQUFFTjtnQkFBT0M7WUFBTztZQUN2Qk0sV0FBVTtzQkFFViw0RUFBQ0M7MEJBQUU7Ozs7Ozs7Ozs7O0lBR1Q7SUFFQSxnREFBZ0Q7SUFDaEQsTUFBTUMsYUFBYUMsS0FBS0MsR0FBRyxJQUFJWixLQUFLYSxHQUFHLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLE1BQU07SUFDN0QsTUFBTUMsU0FBU0wsS0FBS0MsR0FBRyxDQUFDLEtBQUtELEtBQUtDLEdBQUcsSUFBSVosS0FBS2EsR0FBRyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNRyxHQUFHO0lBQ3BFLE1BQU1DLFlBQVlQLEtBQUtDLEdBQUcsSUFBSVosS0FBS2EsR0FBRyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNSyxNQUFNLEdBQUc7SUFFL0R0QixnREFBU0E7a0NBQUM7WUFDUixJQUFJLENBQUNPLFVBQVVnQixPQUFPLElBQUlwQixLQUFLSyxNQUFNLEtBQUssR0FBRztZQUU3QyxNQUFNZ0IsU0FBU2pCLFVBQVVnQixPQUFPO1lBQ2hDLE1BQU1FLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztZQUM5QixJQUFJLENBQUNELEtBQUs7WUFFViw0Q0FBNEM7WUFDNUMsTUFBTUUsVUFBVTtnQkFDZEMsTUFBTTtnQkFDTkMsT0FBTztnQkFDUEMsS0FBSztnQkFDTEMsUUFBUSxHQUFHLGlDQUFpQztZQUM5QztZQUVB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N0IsVUFBVSxTQUFTLFlBQVk7WUFDL0NtQixJQUFJdUIsU0FBUztZQUNidkIsSUFBSWdDLEdBQUcsQ0FBQ1EsVUFBVSxLQUFLQyxTQUFTLEdBQUcsR0FBRyxJQUFJcEQsS0FBSzRDLEVBQUU7WUFDakRqQyxJQUFJa0MsSUFBSTtZQUNSbEMsSUFBSVUsU0FBUyxHQUFHN0IsVUFBVSxTQUFTLFlBQVk7WUFDL0NtQixJQUFJZSxRQUFRLENBQUMsVUFBVXlCLFVBQVUsS0FBS0MsVUFBVTtRQUVsRDtpQ0FBRztRQUFDL0Q7UUFBTUM7UUFBT0M7UUFBUWM7UUFBUUU7UUFBV2Y7UUFBT087S0FBVztJQUU5RCxxQkFDRSw4REFBQ1c7UUFDQzJDLEtBQUs1RDtRQUNMSCxPQUFPQTtRQUNQQyxRQUFRQTtRQUNSTSxXQUFVOzs7Ozs7QUFHaEI7R0EvTk1UO0tBQUFBO0FBaU9OLGlFQUFlQSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRyYWdnXFxPbmVEcml2ZVxcRGVza3RvcFxcV1BNR0FNRVxcY29tcG9uZW50c1xcUmVzdWx0c0dyYXBoLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG50eXBlIERhdGFQb2ludCA9IHtcclxuICBzZWNvbmQ6IG51bWJlcjtcclxuICB3cG06IG51bWJlcjtcclxuICBhY2N1cmFjeTogbnVtYmVyO1xyXG4gIGVycm9yczogbnVtYmVyO1xyXG59O1xyXG5cclxudHlwZSBSZXN1bHRzR3JhcGhQcm9wcyA9IHtcclxuICBkYXRhOiBEYXRhUG9pbnRbXTtcclxuICB3aWR0aD86IG51bWJlcjtcclxuICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgdGhlbWU/OiAnbGlnaHQnIHwgJ2RhcmsnO1xyXG59O1xyXG5cclxuY29uc3QgUmVzdWx0c0dyYXBoOiBSZWFjdC5GQzxSZXN1bHRzR3JhcGhQcm9wcz4gPSAoeyBkYXRhLCB3aWR0aCA9IDkwMCwgaGVpZ2h0ID0gMzAwLCB0aGVtZSA9ICdkYXJrJyB9KSA9PiB7XHJcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuXHJcbiAgLy8gSGFuZGxlIGVkZ2UgY2FzZXMgd2l0aCBtaW5pbWFsIGRhdGFcclxuICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPD0gMSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBcclxuICAgICAgICBzdHlsZT17eyB3aWR0aCwgaGVpZ2h0IH19IFxyXG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtZ3JheS01MDBcIlxyXG4gICAgICA+XHJcbiAgICAgICAgPHA+SW5zdWZmaWNpZW50IGRhdGEgdG8gZGlzcGxheSBncmFwaDwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIG1heFNlY29uZHMgaXMgc2V0IGJhc2VkIG9uIGFjdHVhbCBkYXRhXHJcbiAgY29uc3QgbWF4U2Vjb25kcyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LnNlY29uZCkpO1xyXG4gIGNvbnN0IG1heFdQTSA9IE1hdGgubWF4KDEwMCwgTWF0aC5tYXgoLi4uZGF0YS5tYXAocG9pbnQgPT4gcG9pbnQud3BtKSkpO1xyXG4gIGNvbnN0IG1heEVycm9ycyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LmVycm9ycyksIDUpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEFkZCBwYWRkaW5nIHRvIHByZXZlbnQgY3V0dGluZyBvZmYgbGFiZWxzXHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICBsZWZ0OiA0MCwgIC8vIExlZnQgcGFkZGluZyBmb3IgV1BNIGxhYmVsc1xyXG4gICAgICByaWdodDogNDAsIC8vIFJpZ2h0IHBhZGRpbmcgZm9yIEFjY3VyYWN5IGxhYmVsc1xyXG4gICAgICB0b3A6IDIwLCAgIC8vIFRvcCBwYWRkaW5nIFxyXG4gICAgICBib3R0b206IDI1IC8vIEJvdHRvbSBwYWRkaW5nIGZvciB0aW1lIGxhYmVsc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGp1c3RlZCBkcmF3aW5nIGFyZWFcclxuICAgIGNvbnN0IGRyYXdXaWR0aCA9IHdpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcclxuICAgIGNvbnN0IGRyYXdIZWlnaHQgPSBoZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgIC8vIFNldCB1cCBjYW52YXNcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gQmFja2dyb3VuZCBjb2xvciBiYXNlZCBvbiB0aGVtZVxyXG4gICAgaWYgKHRoZW1lID09PSAnZGFyaycpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMWUyOTNiJzsgLy8gRGFyayBiYWNrZ3JvdW5kXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNmOGZhZmMnOyAvLyBMaWdodCBiYWNrZ3JvdW5kXHJcbiAgICB9XHJcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gRHJhdyBjaGFydCB0aXRsZVxyXG4gICAgY29uc3QgdGl0bGVDb2xvciA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVDb2xvcjtcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTRweCBzYW5zLXNlcmlmJztcclxuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgIGN0eC5maWxsVGV4dCgnUGVyZm9ybWFuY2UgT3ZlciBUaW1lJywgd2lkdGggLyAyLCBwYWRkaW5nLnRvcCAvIDIgKyA1KTtcclxuXHJcbiAgICAvLyBEcmF3IGdyaWRcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzMzNDE1NScgOiAnI2NiZDVlMSc7IC8vIEdyaWQgbGluZXNcclxuICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgV1BNIChsZWZ0IHNpZGUpXHJcbiAgICBjb25zdCB3cG1TdGVwID0gTWF0aC5jZWlsKG1heFdQTSAvIDQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdwbVZhbHVlID0gaSAqIHdwbVN0ZXA7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAod3BtVmFsdWUgLyBtYXhXUE0pICogZHJhd0hlaWdodDtcclxuICAgICAgXHJcbiAgICAgIC8vIERyYXcgaG9yaXpvbnRhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHBhZGRpbmcubGVmdCwgeSk7XHJcbiAgICAgIGN0eC5saW5lVG8ocGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoLCB5KTtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyBXUE0gbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC5mb250ID0gJzExcHggc2Fucy1zZXJpZic7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICBjdHguZmlsbFRleHQoYCR7d3BtVmFsdWV9YCwgcGFkZGluZy5sZWZ0IC0gNSwgeSArIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgQWNjdXJhY3kgKHJpZ2h0IHNpZGUpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA0OyBpKyspIHtcclxuICAgICAgY29uc3QgYWNjdXJhY3lWYWx1ZSA9IGkgKiAyNTsgLy8gMCwgMjUsIDUwLCA3NSwgMTAwXHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAoYWNjdXJhY3lWYWx1ZSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICBcclxuICAgICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHthY2N1cmFjeVZhbHVlfSVgLCBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGggKyA1LCB5ICsgNCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyB4LWF4aXMgKHRpbWUpIGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgY29uc3QgdGltZUludGVydmFsID0gbWF4U2Vjb25kcyA8PSAxNSA/IDUgOiBtYXhTZWNvbmRzIDw9IDMwID8gMTAgOiAxNTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heFNlY29uZHM7IGkgKz0gdGltZUludGVydmFsKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAoaSAvIG1heFNlY29uZHMpICogZHJhd1dpZHRoO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyB2ZXJ0aWNhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHgsIHBhZGRpbmcudG9wKTtcclxuICAgICAgY3R4LmxpbmVUbyh4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEcmF3IHRpbWUgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgY3R4LmZpbGxUZXh0KGAke2l9c2AsIHgsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCArIDE1KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEcmF3IGZpbmFsIHRpbWUgbWFya2VyIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnRlcnZhbHNcclxuICAgIGlmIChtYXhTZWNvbmRzICUgdGltZUludGVydmFsICE9PSAwKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGg7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyM5NGEzYjgnIDogJyM0NzU1NjknO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHttYXhTZWNvbmRzfXNgLCB4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgKyAxNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBXUE0gbGluZVxyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjNGFkZTgwJyA6ICcjMjJjNTVlJzsgLy8gR3JlZW4gbGluZSBmb3IgV1BNXHJcbiAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGRhdGEuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAocG9pbnQuc2Vjb25kIC8gbWF4U2Vjb25kcykgKiBkcmF3V2lkdGg7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAocG9pbnQud3BtIC8gbWF4V1BNKSAqIGRyYXdIZWlnaHQ7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcclxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgIC8vIERyYXcgZXJyb3JzIGFzIHJlZCBkb3RzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZWY0NDQ0JyA6ICcjZGMyNjI2JzsgLy8gUmVkIGZvciBlcnJvcnNcclxuICAgIGRhdGEuZm9yRWFjaChwb2ludCA9PiB7XHJcbiAgICAgIGlmIChwb2ludC5lcnJvcnMgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgICBjb25zdCB5ID0gcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC0gKHBvaW50LndwbSAvIG1heFdQTSkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHgsIHksIDQsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEcmF3IGFjY3VyYWN5IGxpbmVcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7IC8vIEJsdWUgbGluZSBmb3IgYWNjdXJhY3lcclxuICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgZGF0YS5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgY29uc3QgeSA9IHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAtIChwb2ludC5hY2N1cmFjeSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG5cclxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAvLyBEcmF3IGF4aXMgbGFiZWxzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZjhmYWZjJyA6ICcjMWUyOTNiJztcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTJweCBzYW5zLXNlcmlmJztcclxuICAgIFxyXG4gICAgLy8gV1BNIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSgxNSwgcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC8gMik7XHJcbiAgICBjdHgucm90YXRlKC1NYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ1dQTScsIDAsIDApO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gMTUsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAvIDIpO1xyXG4gICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ0FjY3VyYWN5JywgMCwgMCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBUaW1lIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguZmlsbFRleHQoJ1RpbWUgKHNlY29uZHMpJywgcGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoIC8gMiwgaGVpZ2h0IC0gNSk7XHJcblxyXG4gICAgLy8gRHJhdyBsZWdlbmRcclxuICAgIGNvbnN0IGxlZ2VuZFggPSBwYWRkaW5nLmxlZnQgKyAxMDtcclxuICAgIGNvbnN0IGxlZ2VuZFkgPSBwYWRkaW5nLnRvcCArIDE1O1xyXG4gICAgXHJcbiAgICAvLyBXUE0gbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzRhZGU4MCcgOiAnIzIyYzU1ZSc7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFgsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LmxpbmVUbyhsZWdlbmRYICsgMjAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdXUE0nLCBsZWdlbmRYICsgMjUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFggKyA4MCwgbGVnZW5kWSk7XHJcbiAgICBjdHgubGluZVRvKGxlZ2VuZFggKyAxMDAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdBY2N1cmFjeScsIGxlZ2VuZFggKyAxMDUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gRXJyb3IgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyNlZjQ0NDQnIDogJyNkYzI2MjYnO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyhsZWdlbmRYICsgMTkwLCBsZWdlbmRZLCA0LCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFRleHQoJ0Vycm9ycycsIGxlZ2VuZFggKyAyMDAsIGxlZ2VuZFkgKyA0KTtcclxuXHJcbiAgfSwgW2RhdGEsIHdpZHRoLCBoZWlnaHQsIG1heFdQTSwgbWF4RXJyb3JzLCB0aGVtZSwgbWF4U2Vjb25kc10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGNhbnZhcyBcclxuICAgICAgcmVmPXtjYW52YXNSZWZ9IFxyXG4gICAgICB3aWR0aD17d2lkdGh9IFxyXG4gICAgICBoZWlnaHQ9e2hlaWdodH0gXHJcbiAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtbWQgbXgtYXV0b1wiXHJcbiAgICAvPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZXN1bHRzR3JhcGg7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlJlc3VsdHNHcmFwaCIsImRhdGEiLCJ3aWR0aCIsImhlaWdodCIsInRoZW1lIiwiY2FudmFzUmVmIiwibGVuZ3RoIiwiZGl2Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJwIiwibWF4U2Vjb25kcyIsIk1hdGgiLCJtYXgiLCJtYXAiLCJwb2ludCIsInNlY29uZCIsIm1heFdQTSIsIndwbSIsIm1heEVycm9ycyIsImVycm9ycyIsImN1cnJlbnQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwicGFkZGluZyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImRyYXdXaWR0aCIsImRyYXdIZWlnaHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRpdGxlQ29sb3IiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIndwbVN0ZXAiLCJjZWlsIiwiaSIsIndwbVZhbHVlIiwieSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImFjY3VyYWN5VmFsdWUiLCJ0aW1lSW50ZXJ2YWwiLCJ4IiwiZm9yRWFjaCIsImluZGV4IiwiYXJjIiwiUEkiLCJmaWxsIiwiYWNjdXJhY3kiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVzdG9yZSIsImxlZ2VuZFgiLCJsZWdlbmRZIiwicmVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/ResultsGraph.tsx\n"));

/***/ })

});