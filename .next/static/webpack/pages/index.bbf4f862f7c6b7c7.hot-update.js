"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./components/ResultsGraph.tsx":
/*!*************************************!*\
  !*** ./components/ResultsGraph.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * ResultsGraph Component\r\n * \r\n * Renders a canvas-based performance graph showing:\r\n * - WPM over time\r\n * - Accuracy percentage over time\r\n * - Error indicators\r\n * - Supports both light and dark themes\r\n */ \nvar _s = $RefreshSig$();\n\nconst ResultsGraph = (param)=>{\n    let { data, width = 900, height = 300, theme = 'dark' } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Handle edge cases with minimal data\n    if (!data || data.length <= 1) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width,\n                height\n            },\n            className: \"flex items-center justify-center text-gray-500\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Insufficient data to display graph\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n                lineNumber: 36,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n            lineNumber: 32,\n            columnNumber: 7\n        }, undefined);\n    }\n    // Ensure maxSeconds is set based on actual data\n    const maxSeconds = Math.max(...data.map((point)=>point.second));\n    const maxWPM = Math.max(100, Math.max(...data.map((point)=>point.wpm)));\n    const maxErrors = Math.max(...data.map((point)=>point.errors), 5);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResultsGraph.useEffect\": ()=>{\n            if (!canvasRef.current || data.length === 0) return;\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            // Add padding to prevent cutting off labels\n            const padding = {\n                left: 40,\n                right: 40,\n                top: 20,\n                bottom: 25 // Bottom padding for time labels\n            };\n            // Adjusted drawing area\n            const drawWidth = width - padding.left - padding.right;\n            const drawHeight = height - padding.top - padding.bottom;\n            // Set up canvas\n            ctx.clearRect(0, 0, width, height);\n            // Background color based on theme\n            if (theme === 'dark') {\n                ctx.fillStyle = '#1e293b'; // Dark background\n            } else {\n                ctx.fillStyle = '#f8fafc'; // Light background\n            }\n            ctx.fillRect(0, 0, width, height);\n            // Draw chart title\n            const titleColor = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillStyle = titleColor;\n            ctx.font = 'bold 14px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText('Performance Over Time', width / 2, padding.top / 2 + 5);\n            // Draw legend at the top of the graph, below the title\n            const legendY = padding.top / 2 + 20;\n            const legendX = width / 2 - 120; // Center the legend\n            // WPM legend item\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e';\n            ctx.beginPath();\n            ctx.moveTo(legendX, legendY);\n            ctx.lineTo(legendX + 20, legendY);\n            ctx.stroke();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.textAlign = 'left';\n            ctx.fillText('WPM', legendX + 25, legendY + 4);\n            // Accuracy legend item\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6';\n            ctx.beginPath();\n            ctx.moveTo(legendX + 80, legendY);\n            ctx.lineTo(legendX + 100, legendY);\n            ctx.stroke();\n            ctx.fillText('Accuracy', legendX + 105, legendY + 4);\n            // Error legend item\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626';\n            ctx.beginPath();\n            ctx.arc(legendX + 190, legendY, 4, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.fillText('Errors', legendX + 200, legendY + 4);\n            // Draw grid\n            ctx.strokeStyle = theme === 'dark' ? '#334155' : '#cbd5e1'; // Grid lines\n            ctx.lineWidth = 1;\n            // Draw y-axis labels for WPM (left side)\n            const wpmStep = Math.ceil(maxWPM / 4);\n            for(let i = 0; i <= 4; i++){\n                const wpmValue = i * wpmStep;\n                const y = padding.top + drawHeight - wpmValue / maxWPM * drawHeight;\n                // Draw horizontal grid line\n                ctx.beginPath();\n                ctx.moveTo(padding.left, y);\n                ctx.lineTo(padding.left + drawWidth, y);\n                ctx.stroke();\n                // Draw WPM label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.font = '11px sans-serif';\n                ctx.textAlign = 'right';\n                ctx.fillText(\"\".concat(wpmValue), padding.left - 5, y + 4);\n            }\n            // Draw y-axis labels for Accuracy (right side)\n            for(let i = 0; i <= 4; i++){\n                const accuracyValue = i * 25; // 0, 25, 50, 75, 100\n                const y = padding.top + drawHeight - accuracyValue / 100 * drawHeight;\n                // Accuracy label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'left';\n                ctx.fillText(\"\".concat(accuracyValue, \"%\"), padding.left + drawWidth + 5, y + 4);\n            }\n            // Draw x-axis (time) labels and vertical grid lines\n            const timeInterval = maxSeconds <= 15 ? 5 : maxSeconds <= 30 ? 10 : 15;\n            for(let i = 0; i <= maxSeconds; i += timeInterval){\n                const x = padding.left + i / maxSeconds * drawWidth;\n                // Draw vertical grid line\n                ctx.beginPath();\n                ctx.moveTo(x, padding.top);\n                ctx.lineTo(x, padding.top + drawHeight);\n                ctx.stroke();\n                // Draw time label\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(i, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw final time marker if not included in intervals\n            if (maxSeconds % timeInterval !== 0) {\n                const x = padding.left + drawWidth;\n                ctx.fillStyle = theme === 'dark' ? '#94a3b8' : '#475569';\n                ctx.textAlign = 'center';\n                ctx.fillText(\"\".concat(maxSeconds, \"s\"), x, padding.top + drawHeight + 15);\n            }\n            // Draw WPM line\n            ctx.strokeStyle = theme === 'dark' ? '#4ade80' : '#22c55e'; // Green line for WPM\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw errors as red dots\n            ctx.fillStyle = theme === 'dark' ? '#ef4444' : '#dc2626'; // Red for errors\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point)=>{\n                    if (point.errors > 0) {\n                        const x = padding.left + point.second / maxSeconds * drawWidth;\n                        const y = padding.top + drawHeight - point.wpm / maxWPM * drawHeight;\n                        ctx.beginPath();\n                        ctx.arc(x, y, 4, 0, 2 * Math.PI);\n                        ctx.fill();\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            // Draw accuracy line\n            ctx.strokeStyle = theme === 'dark' ? '#60a5fa' : '#3b82f6'; // Blue line for accuracy\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            data.forEach({\n                \"ResultsGraph.useEffect\": (point, index)=>{\n                    const x = padding.left + point.second / maxSeconds * drawWidth;\n                    const y = padding.top + drawHeight - point.accuracy / 100 * drawHeight;\n                    if (index === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n            }[\"ResultsGraph.useEffect\"]);\n            ctx.stroke();\n            // Draw axis labels\n            ctx.fillStyle = theme === 'dark' ? '#f8fafc' : '#1e293b';\n            ctx.font = 'bold 12px sans-serif';\n            // WPM label\n            ctx.textAlign = 'center';\n            ctx.save();\n            ctx.translate(15, padding.top + drawHeight / 2);\n            ctx.rotate(-Math.PI / 2);\n            ctx.fillText('WPM', 0, 0);\n            ctx.restore();\n            // Accuracy label\n            ctx.save();\n            ctx.translate(width - 15, padding.top + drawHeight / 2);\n            ctx.rotate(Math.PI / 2);\n            ctx.fillText('Accuracy', 0, 0);\n            ctx.restore();\n            // Time label\n            ctx.textAlign = 'center';\n            ctx.fillText('Time (seconds)', padding.left + drawWidth / 2, height - 5);\n        }\n    }[\"ResultsGraph.useEffect\"], [\n        data,\n        width,\n        height,\n        maxWPM,\n        maxErrors,\n        theme,\n        maxSeconds\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height,\n        className: \"rounded-md mx-auto\"\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\dragg\\\\OneDrive\\\\Desktop\\\\WPMGAME\\\\components\\\\ResultsGraph.tsx\",\n        lineNumber: 242,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ResultsGraph, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = ResultsGraph;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ResultsGraph);\nvar _c;\n$RefreshReg$(_c, \"ResultsGraph\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvUmVzdWx0c0dyYXBoLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7OztDQVFDOztBQUNnRDtBQWdCakQsTUFBTUcsZUFBNEM7UUFBQyxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsR0FBRyxFQUFFQyxTQUFTLEdBQUcsRUFBRUMsUUFBUSxNQUFNLEVBQUU7O0lBQ3BHLE1BQU1DLFlBQVlOLDZDQUFNQSxDQUFvQjtJQUU1QyxzQ0FBc0M7SUFDdEMsSUFBSSxDQUFDRSxRQUFRQSxLQUFLSyxNQUFNLElBQUksR0FBRztRQUM3QixxQkFDRSw4REFBQ0M7WUFDQ0MsT0FBTztnQkFBRU47Z0JBQU9DO1lBQU87WUFDdkJNLFdBQVU7c0JBRVYsNEVBQUNDOzBCQUFFOzs7Ozs7Ozs7OztJQUdUO0lBRUEsZ0RBQWdEO0lBQ2hELE1BQU1DLGFBQWFDLEtBQUtDLEdBQUcsSUFBSVosS0FBS2EsR0FBRyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNQyxNQUFNO0lBQzdELE1BQU1DLFNBQVNMLEtBQUtDLEdBQUcsQ0FBQyxLQUFLRCxLQUFLQyxHQUFHLElBQUlaLEtBQUthLEdBQUcsQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUcsR0FBRztJQUNwRSxNQUFNQyxZQUFZUCxLQUFLQyxHQUFHLElBQUlaLEtBQUthLEdBQUcsQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUssTUFBTSxHQUFHO0lBRS9EdEIsZ0RBQVNBO2tDQUFDO1lBQ1IsSUFBSSxDQUFDTyxVQUFVZ0IsT0FBTyxJQUFJcEIsS0FBS0ssTUFBTSxLQUFLLEdBQUc7WUFFN0MsTUFBTWdCLFNBQVNqQixVQUFVZ0IsT0FBTztZQUNoQyxNQUFNRSxNQUFNRCxPQUFPRSxVQUFVLENBQUM7WUFDOUIsSUFBSSxDQUFDRCxLQUFLO1lBRVYsNENBQTRDO1lBQzVDLE1BQU1FLFVBQVU7Z0JBQ2RDLE1BQU07Z0JBQ05DLE9BQU87Z0JBQ1BDLEtBQUs7Z0JBQ0xDLFFBQVEsR0FBRyxpQ0FBaUM7WUFDOUM7WUFFQSx3QkFBd0I7WUFDeEIsTUFBTUMsWUFBWTVCLFFBQVF1QixRQUFRQyxJQUFJLEdBQUdELFFBQVFFLEtBQUs7WUFDdEQsTUFBTUksYUFBYTVCLFNBQVNzQixRQUFRRyxHQUFHLEdBQUdILFFBQVFJLE1BQU07WUFFeEQsZ0JBQWdCO1lBQ2hCTixJQUFJUyxTQUFTLENBQUMsR0FBRyxHQUFHOUIsT0FBT0M7WUFFM0Isa0NBQWtDO1lBQ2xDLElBQUlDLFVBQVUsUUFBUTtnQkFDcEJtQixJQUFJVSxTQUFTLEdBQUcsV0FBVyxrQkFBa0I7WUFDL0MsT0FBTztnQkFDTFYsSUFBSVUsU0FBUyxHQUFHLFdBQVcsbUJBQW1CO1lBQ2hEO1lBQ0FWLElBQUlXLFFBQVEsQ0FBQyxHQUFHLEdBQUdoQyxPQUFPQztZQUUxQixtQkFBbUI7WUFDbkIsTUFBTWdDLGFBQWEvQixVQUFVLFNBQVMsWUFBWTtZQUNsRG1CLElBQUlVLFNBQVMsR0FBR0U7WUFDaEJaLElBQUlhLElBQUksR0FBRztZQUNYYixJQUFJYyxTQUFTLEdBQUc7WUFDaEJkLElBQUllLFFBQVEsQ0FBQyx5QkFBeUJwQyxRQUFRLEdBQUd1QixRQUFRRyxHQUFHLEdBQUcsSUFBSTtZQUVuRSx1REFBdUQ7WUFDdkQsTUFBTVcsVUFBVWQsUUFBUUcsR0FBRyxHQUFHLElBQUk7WUFDbEMsTUFBTVksVUFBVXRDLFFBQVEsSUFBSSxLQUFLLG9CQUFvQjtZQUVyRCxrQkFBa0I7WUFDbEJxQixJQUFJa0IsV0FBVyxHQUFHckMsVUFBVSxTQUFTLFlBQVk7WUFDakRtQixJQUFJbUIsU0FBUztZQUNibkIsSUFBSW9CLE1BQU0sQ0FBQ0gsU0FBU0Q7WUFDcEJoQixJQUFJcUIsTUFBTSxDQUFDSixVQUFVLElBQUlEO1lBQ3pCaEIsSUFBSXNCLE1BQU07WUFDVnRCLElBQUlVLFNBQVMsR0FBRzdCLFVBQVUsU0FBUyxZQUFZO1lBQy9DbUIsSUFBSWMsU0FBUyxHQUFHO1lBQ2hCZCxJQUFJZSxRQUFRLENBQUMsT0FBT0UsVUFBVSxJQUFJRCxVQUFVO1lBRTVDLHVCQUF1QjtZQUN2QmhCLElBQUlrQixXQUFXLEdBQUdyQyxVQUFVLFNBQVMsWUFBWTtZQUNqRG1CLElBQUltQixTQUFTO1lBQ2JuQixJQUFJb0IsTUFBTSxDQUFDSCxVQUFVLElBQUlEO1lBQ3pCaEIsSUFBSXFCLE1BQU0sQ0FBQ0osVUFBVSxLQUFLRDtZQUMxQmhCLElBQUlzQixNQUFNO1lBQ1Z0QixJQUFJZSxRQUFRLENBQUMsWUFBWUUsVUFBVSxLQUFLRCxVQUFVO1lBRWxELG9CQUFvQjtZQUNwQmhCLElBQUlVLFNBQVMsR0FBRzdCLFVBQVUsU0FBUyxZQUFZO1lBQy9DbUIsSUFBSW1CLFNBQVM7WUFDYm5CLElBQUl1QixHQUFHLENBQUNOLFVBQVUsS0FBS0QsU0FBUyxHQUFHLEdBQUcsSUFBSTNCLEtBQUttQyxFQUFFO1lBQ2pEeEIsSUFBSXlCLElBQUk7WUFDUnpCLElBQUlVLFNBQVMsR0FBRzdCLFVBQVUsU0FBUyxZQUFZO1lBQy9DbUIsSUFBSWUsUUFBUSxDQUFDLFVBQVVFLFVBQVUsS0FBS0QsVUFBVTtZQUVoRCxZQUFZO1lBQ1poQixJQUFJa0IsV0FBVyxHQUFHckMsVUFBVSxTQUFTLFlBQVksV0FBVyxhQUFhO1lBQ3pFbUIsSUFBSTBCLFNBQVMsR0FBRztZQUVoQix5Q0FBeUM7WUFDekMsTUFBTUMsVUFBVXRDLEtBQUt1QyxJQUFJLENBQUNsQyxTQUFTO1lBQ25DLElBQUssSUFBSW1DLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUMzQixNQUFNQyxXQUFXRCxJQUFJRjtnQkFDckIsTUFBTUksSUFBSTdCLFFBQVFHLEdBQUcsR0FBR0csYUFBYSxXQUFZZCxTQUFVYztnQkFFM0QsNEJBQTRCO2dCQUM1QlIsSUFBSW1CLFNBQVM7Z0JBQ2JuQixJQUFJb0IsTUFBTSxDQUFDbEIsUUFBUUMsSUFBSSxFQUFFNEI7Z0JBQ3pCL0IsSUFBSXFCLE1BQU0sQ0FBQ25CLFFBQVFDLElBQUksR0FBR0ksV0FBV3dCO2dCQUNyQy9CLElBQUlzQixNQUFNO2dCQUVWLGlCQUFpQjtnQkFDakJ0QixJQUFJVSxTQUFTLEdBQUc3QixVQUFVLFNBQVMsWUFBWTtnQkFDL0NtQixJQUFJYSxJQUFJLEdBQUc7Z0JBQ1hiLElBQUljLFNBQVMsR0FBRztnQkFDaEJkLElBQUllLFFBQVEsQ0FBQyxHQUFZLE9BQVRlLFdBQVk1QixRQUFRQyxJQUFJLEdBQUcsR0FBRzRCLElBQUk7WUFDcEQ7WUFFQSwrQ0FBK0M7WUFDL0MsSUFBSyxJQUFJRixJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBSztnQkFDM0IsTUFBTUcsZ0JBQWdCSCxJQUFJLElBQUkscUJBQXFCO2dCQUNuRCxNQUFNRSxJQUFJN0IsUUFBUUcsR0FBRyxHQUFHRyxhQUFhLGdCQUFpQixNQUFPQTtnQkFFN0QsaUJBQWlCO2dCQUNqQlIsSUFBSVUsU0FBUyxHQUFHN0IsVUFBVSxTQUFTLFlBQVk7Z0JBQy9DbUIsSUFBSWMsU0FBUyxHQUFHO2dCQUNoQmQsSUFBSWUsUUFBUSxDQUFDLEdBQWlCLE9BQWRpQixlQUFjLE1BQUk5QixRQUFRQyxJQUFJLEdBQUdJLFlBQVksR0FBR3dCLElBQUk7WUFDdEU7WUFFQSxvREFBb0Q7WUFDcEQsTUFBTUUsZUFBZTdDLGNBQWMsS0FBSyxJQUFJQSxjQUFjLEtBQUssS0FBSztZQUNwRSxJQUFLLElBQUl5QyxJQUFJLEdBQUdBLEtBQUt6QyxZQUFZeUMsS0FBS0ksYUFBYztnQkFDbEQsTUFBTUMsSUFBSWhDLFFBQVFDLElBQUksR0FBRyxJQUFLZixhQUFjbUI7Z0JBRTVDLDBCQUEwQjtnQkFDMUJQLElBQUltQixTQUFTO2dCQUNibkIsSUFBSW9CLE1BQU0sQ0FBQ2MsR0FBR2hDLFFBQVFHLEdBQUc7Z0JBQ3pCTCxJQUFJcUIsTUFBTSxDQUFDYSxHQUFHaEMsUUFBUUcsR0FBRyxHQUFHRztnQkFDNUJSLElBQUlzQixNQUFNO2dCQUVWLGtCQUFrQjtnQkFDbEJ0QixJQUFJVSxTQUFTLEdBQUc3QixVQUFVLFNBQVMsWUFBWTtnQkFDL0NtQixJQUFJYyxTQUFTLEdBQUc7Z0JBQ2hCZCxJQUFJZSxRQUFRLENBQUMsR0FBSyxPQUFGYyxHQUFFLE1BQUlLLEdBQUdoQyxRQUFRRyxHQUFHLEdBQUdHLGFBQWE7WUFDdEQ7WUFFQSxzREFBc0Q7WUFDdEQsSUFBSXBCLGFBQWE2QyxpQkFBaUIsR0FBRztnQkFDbkMsTUFBTUMsSUFBSWhDLFFBQVFDLElBQUksR0FBR0k7Z0JBQ3pCUCxJQUFJVSxTQUFTLEdBQUc3QixVQUFVLFNBQVMsWUFBWTtnQkFDL0NtQixJQUFJYyxTQUFTLEdBQUc7Z0JBQ2hCZCxJQUFJZSxRQUFRLENBQUMsR0FBYyxPQUFYM0IsWUFBVyxNQUFJOEMsR0FBR2hDLFFBQVFHLEdBQUcsR0FBR0csYUFBYTtZQUMvRDtZQUVBLGdCQUFnQjtZQUNoQlIsSUFBSWtCLFdBQVcsR0FBR3JDLFVBQVUsU0FBUyxZQUFZLFdBQVcscUJBQXFCO1lBQ2pGbUIsSUFBSTBCLFNBQVMsR0FBRztZQUNoQjFCLElBQUltQixTQUFTO1lBQ2J6QyxLQUFLeUQsT0FBTzswQ0FBQyxDQUFDM0MsT0FBTzRDO29CQUNuQixNQUFNRixJQUFJaEMsUUFBUUMsSUFBSSxHQUFHLE1BQU9WLE1BQU0sR0FBR0wsYUFBY21CO29CQUN2RCxNQUFNd0IsSUFBSTdCLFFBQVFHLEdBQUcsR0FBR0csYUFBYSxNQUFPYixHQUFHLEdBQUdELFNBQVVjO29CQUU1RCxJQUFJNEIsVUFBVSxHQUFHO3dCQUNmcEMsSUFBSW9CLE1BQU0sQ0FBQ2MsR0FBR0g7b0JBQ2hCLE9BQU87d0JBQ0wvQixJQUFJcUIsTUFBTSxDQUFDYSxHQUFHSDtvQkFDaEI7Z0JBQ0Y7O1lBQ0EvQixJQUFJc0IsTUFBTTtZQUVWLDBCQUEwQjtZQUMxQnRCLElBQUlVLFNBQVMsR0FBRzdCLFVBQVUsU0FBUyxZQUFZLFdBQVcsaUJBQWlCO1lBQzNFSCxLQUFLeUQsT0FBTzswQ0FBQzNDLENBQUFBO29CQUNYLElBQUlBLE1BQU1LLE1BQU0sR0FBRyxHQUFHO3dCQUNwQixNQUFNcUMsSUFBSWhDLFFBQVFDLElBQUksR0FBRyxNQUFPVixNQUFNLEdBQUdMLGFBQWNtQjt3QkFDdkQsTUFBTXdCLElBQUk3QixRQUFRRyxHQUFHLEdBQUdHLGFBQWEsTUFBT2IsR0FBRyxHQUFHRCxTQUFVYzt3QkFDNURSLElBQUltQixTQUFTO3dCQUNibkIsSUFBSXVCLEdBQUcsQ0FBQ1csR0FBR0gsR0FBRyxHQUFHLEdBQUcsSUFBSTFDLEtBQUttQyxFQUFFO3dCQUMvQnhCLElBQUl5QixJQUFJO29CQUNWO2dCQUNGOztZQUVBLHFCQUFxQjtZQUNyQnpCLElBQUlrQixXQUFXLEdBQUdyQyxVQUFVLFNBQVMsWUFBWSxXQUFXLHlCQUF5QjtZQUNyRm1CLElBQUkwQixTQUFTLEdBQUc7WUFDaEIxQixJQUFJbUIsU0FBUztZQUNiekMsS0FBS3lELE9BQU87MENBQUMsQ0FBQzNDLE9BQU80QztvQkFDbkIsTUFBTUYsSUFBSWhDLFFBQVFDLElBQUksR0FBRyxNQUFPVixNQUFNLEdBQUdMLGFBQWNtQjtvQkFDdkQsTUFBTXdCLElBQUk3QixRQUFRRyxHQUFHLEdBQUdHLGFBQWEsTUFBTzZCLFFBQVEsR0FBRyxNQUFPN0I7b0JBRTlELElBQUk0QixVQUFVLEdBQUc7d0JBQ2ZwQyxJQUFJb0IsTUFBTSxDQUFDYyxHQUFHSDtvQkFDaEIsT0FBTzt3QkFDTC9CLElBQUlxQixNQUFNLENBQUNhLEdBQUdIO29CQUNoQjtnQkFDRjs7WUFDQS9CLElBQUlzQixNQUFNO1lBRVYsbUJBQW1CO1lBQ25CdEIsSUFBSVUsU0FBUyxHQUFHN0IsVUFBVSxTQUFTLFlBQVk7WUFDL0NtQixJQUFJYSxJQUFJLEdBQUc7WUFFWCxZQUFZO1lBQ1piLElBQUljLFNBQVMsR0FBRztZQUNoQmQsSUFBSXNDLElBQUk7WUFDUnRDLElBQUl1QyxTQUFTLENBQUMsSUFBSXJDLFFBQVFHLEdBQUcsR0FBR0csYUFBYTtZQUM3Q1IsSUFBSXdDLE1BQU0sQ0FBQyxDQUFDbkQsS0FBS21DLEVBQUUsR0FBRztZQUN0QnhCLElBQUllLFFBQVEsQ0FBQyxPQUFPLEdBQUc7WUFDdkJmLElBQUl5QyxPQUFPO1lBRVgsaUJBQWlCO1lBQ2pCekMsSUFBSXNDLElBQUk7WUFDUnRDLElBQUl1QyxTQUFTLENBQUM1RCxRQUFRLElBQUl1QixRQUFRRyxHQUFHLEdBQUdHLGFBQWE7WUFDckRSLElBQUl3QyxNQUFNLENBQUNuRCxLQUFLbUMsRUFBRSxHQUFHO1lBQ3JCeEIsSUFBSWUsUUFBUSxDQUFDLFlBQVksR0FBRztZQUM1QmYsSUFBSXlDLE9BQU87WUFFWCxhQUFhO1lBQ2J6QyxJQUFJYyxTQUFTLEdBQUc7WUFDaEJkLElBQUllLFFBQVEsQ0FBQyxrQkFBa0JiLFFBQVFDLElBQUksR0FBR0ksWUFBWSxHQUFHM0IsU0FBUztRQUV4RTtpQ0FBRztRQUFDRjtRQUFNQztRQUFPQztRQUFRYztRQUFRRTtRQUFXZjtRQUFPTztLQUFXO0lBRTlELHFCQUNFLDhEQUFDVztRQUNDMkMsS0FBSzVEO1FBQ0xILE9BQU9BO1FBQ1BDLFFBQVFBO1FBQ1JNLFdBQVU7Ozs7OztBQUdoQjtHQS9OTVQ7S0FBQUE7QUFpT04saUVBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZHJhZ2dcXE9uZURyaXZlXFxEZXNrdG9wXFxXUE1HQU1FXFxjb21wb25lbnRzXFxSZXN1bHRzR3JhcGgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBSZXN1bHRzR3JhcGggQ29tcG9uZW50XHJcbiAqIFxyXG4gKiBSZW5kZXJzIGEgY2FudmFzLWJhc2VkIHBlcmZvcm1hbmNlIGdyYXBoIHNob3dpbmc6XHJcbiAqIC0gV1BNIG92ZXIgdGltZVxyXG4gKiAtIEFjY3VyYWN5IHBlcmNlbnRhZ2Ugb3ZlciB0aW1lXHJcbiAqIC0gRXJyb3IgaW5kaWNhdG9yc1xyXG4gKiAtIFN1cHBvcnRzIGJvdGggbGlnaHQgYW5kIGRhcmsgdGhlbWVzXHJcbiAqL1xyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG50eXBlIERhdGFQb2ludCA9IHtcclxuICBzZWNvbmQ6IG51bWJlcjtcclxuICB3cG06IG51bWJlcjtcclxuICBhY2N1cmFjeTogbnVtYmVyO1xyXG4gIGVycm9yczogbnVtYmVyO1xyXG59O1xyXG5cclxudHlwZSBSZXN1bHRzR3JhcGhQcm9wcyA9IHtcclxuICBkYXRhOiBEYXRhUG9pbnRbXTtcclxuICB3aWR0aD86IG51bWJlcjtcclxuICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgdGhlbWU/OiAnbGlnaHQnIHwgJ2RhcmsnO1xyXG59O1xyXG5cclxuY29uc3QgUmVzdWx0c0dyYXBoOiBSZWFjdC5GQzxSZXN1bHRzR3JhcGhQcm9wcz4gPSAoeyBkYXRhLCB3aWR0aCA9IDkwMCwgaGVpZ2h0ID0gMzAwLCB0aGVtZSA9ICdkYXJrJyB9KSA9PiB7XHJcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuXHJcbiAgLy8gSGFuZGxlIGVkZ2UgY2FzZXMgd2l0aCBtaW5pbWFsIGRhdGFcclxuICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPD0gMSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBcclxuICAgICAgICBzdHlsZT17eyB3aWR0aCwgaGVpZ2h0IH19IFxyXG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtZ3JheS01MDBcIlxyXG4gICAgICA+XHJcbiAgICAgICAgPHA+SW5zdWZmaWNpZW50IGRhdGEgdG8gZGlzcGxheSBncmFwaDwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIG1heFNlY29uZHMgaXMgc2V0IGJhc2VkIG9uIGFjdHVhbCBkYXRhXHJcbiAgY29uc3QgbWF4U2Vjb25kcyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LnNlY29uZCkpO1xyXG4gIGNvbnN0IG1heFdQTSA9IE1hdGgubWF4KDEwMCwgTWF0aC5tYXgoLi4uZGF0YS5tYXAocG9pbnQgPT4gcG9pbnQud3BtKSkpO1xyXG4gIGNvbnN0IG1heEVycm9ycyA9IE1hdGgubWF4KC4uLmRhdGEubWFwKHBvaW50ID0+IHBvaW50LmVycm9ycyksIDUpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIEFkZCBwYWRkaW5nIHRvIHByZXZlbnQgY3V0dGluZyBvZmYgbGFiZWxzXHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICBsZWZ0OiA0MCwgIC8vIExlZnQgcGFkZGluZyBmb3IgV1BNIGxhYmVsc1xyXG4gICAgICByaWdodDogNDAsIC8vIFJpZ2h0IHBhZGRpbmcgZm9yIEFjY3VyYWN5IGxhYmVsc1xyXG4gICAgICB0b3A6IDIwLCAgIC8vIFRvcCBwYWRkaW5nIFxyXG4gICAgICBib3R0b206IDI1IC8vIEJvdHRvbSBwYWRkaW5nIGZvciB0aW1lIGxhYmVsc1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGp1c3RlZCBkcmF3aW5nIGFyZWFcclxuICAgIGNvbnN0IGRyYXdXaWR0aCA9IHdpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodDtcclxuICAgIGNvbnN0IGRyYXdIZWlnaHQgPSBoZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgIC8vIFNldCB1cCBjYW52YXNcclxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gQmFja2dyb3VuZCBjb2xvciBiYXNlZCBvbiB0aGVtZVxyXG4gICAgaWYgKHRoZW1lID09PSAnZGFyaycpIHtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMWUyOTNiJzsgLy8gRGFyayBiYWNrZ3JvdW5kXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJyNmOGZhZmMnOyAvLyBMaWdodCBiYWNrZ3JvdW5kXHJcbiAgICB9XHJcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgLy8gRHJhdyBjaGFydCB0aXRsZVxyXG4gICAgY29uc3QgdGl0bGVDb2xvciA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVDb2xvcjtcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTRweCBzYW5zLXNlcmlmJztcclxuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgIGN0eC5maWxsVGV4dCgnUGVyZm9ybWFuY2UgT3ZlciBUaW1lJywgd2lkdGggLyAyLCBwYWRkaW5nLnRvcCAvIDIgKyA1KTtcclxuXHJcbiAgICAvLyBEcmF3IGxlZ2VuZCBhdCB0aGUgdG9wIG9mIHRoZSBncmFwaCwgYmVsb3cgdGhlIHRpdGxlXHJcbiAgICBjb25zdCBsZWdlbmRZID0gcGFkZGluZy50b3AgLyAyICsgMjA7XHJcbiAgICBjb25zdCBsZWdlbmRYID0gd2lkdGggLyAyIC0gMTIwOyAvLyBDZW50ZXIgdGhlIGxlZ2VuZFxyXG4gICAgXHJcbiAgICAvLyBXUE0gbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzRhZGU4MCcgOiAnIzIyYzU1ZSc7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFgsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LmxpbmVUbyhsZWdlbmRYICsgMjAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdXUE0nLCBsZWdlbmRYICsgMjUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKGxlZ2VuZFggKyA4MCwgbGVnZW5kWSk7XHJcbiAgICBjdHgubGluZVRvKGxlZ2VuZFggKyAxMDAsIGxlZ2VuZFkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgY3R4LmZpbGxUZXh0KCdBY2N1cmFjeScsIGxlZ2VuZFggKyAxMDUsIGxlZ2VuZFkgKyA0KTtcclxuICAgIFxyXG4gICAgLy8gRXJyb3IgbGVnZW5kIGl0ZW1cclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyNlZjQ0NDQnIDogJyNkYzI2MjYnO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyhsZWdlbmRYICsgMTkwLCBsZWdlbmRZLCA0LCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnI2Y4ZmFmYycgOiAnIzFlMjkzYic7XHJcbiAgICBjdHguZmlsbFRleHQoJ0Vycm9ycycsIGxlZ2VuZFggKyAyMDAsIGxlZ2VuZFkgKyA0KTtcclxuXHJcbiAgICAvLyBEcmF3IGdyaWRcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzMzNDE1NScgOiAnI2NiZDVlMSc7IC8vIEdyaWQgbGluZXNcclxuICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgV1BNIChsZWZ0IHNpZGUpXHJcbiAgICBjb25zdCB3cG1TdGVwID0gTWF0aC5jZWlsKG1heFdQTSAvIDQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdwbVZhbHVlID0gaSAqIHdwbVN0ZXA7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAod3BtVmFsdWUgLyBtYXhXUE0pICogZHJhd0hlaWdodDtcclxuICAgICAgXHJcbiAgICAgIC8vIERyYXcgaG9yaXpvbnRhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHBhZGRpbmcubGVmdCwgeSk7XHJcbiAgICAgIGN0eC5saW5lVG8ocGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoLCB5KTtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyBXUE0gbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC5mb250ID0gJzExcHggc2Fucy1zZXJpZic7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICBjdHguZmlsbFRleHQoYCR7d3BtVmFsdWV9YCwgcGFkZGluZy5sZWZ0IC0gNSwgeSArIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgeS1heGlzIGxhYmVscyBmb3IgQWNjdXJhY3kgKHJpZ2h0IHNpZGUpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA0OyBpKyspIHtcclxuICAgICAgY29uc3QgYWNjdXJhY3lWYWx1ZSA9IGkgKiAyNTsgLy8gMCwgMjUsIDUwLCA3NSwgMTAwXHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAoYWNjdXJhY3lWYWx1ZSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICBcclxuICAgICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHthY2N1cmFjeVZhbHVlfSVgLCBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGggKyA1LCB5ICsgNCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyB4LWF4aXMgKHRpbWUpIGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xyXG4gICAgY29uc3QgdGltZUludGVydmFsID0gbWF4U2Vjb25kcyA8PSAxNSA/IDUgOiBtYXhTZWNvbmRzIDw9IDMwID8gMTAgOiAxNTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heFNlY29uZHM7IGkgKz0gdGltZUludGVydmFsKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAoaSAvIG1heFNlY29uZHMpICogZHJhd1dpZHRoO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyB2ZXJ0aWNhbCBncmlkIGxpbmVcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHgsIHBhZGRpbmcudG9wKTtcclxuICAgICAgY3R4LmxpbmVUbyh4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEcmF3IHRpbWUgbGFiZWxcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzk0YTNiOCcgOiAnIzQ3NTU2OSc7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgY3R4LmZpbGxUZXh0KGAke2l9c2AsIHgsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCArIDE1KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEcmF3IGZpbmFsIHRpbWUgbWFya2VyIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnRlcnZhbHNcclxuICAgIGlmIChtYXhTZWNvbmRzICUgdGltZUludGVydmFsICE9PSAwKSB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyBkcmF3V2lkdGg7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZSA9PT0gJ2RhcmsnID8gJyM5NGEzYjgnIDogJyM0NzU1NjknO1xyXG4gICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgIGN0eC5maWxsVGV4dChgJHttYXhTZWNvbmRzfXNgLCB4LCBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgKyAxNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBXUE0gbGluZVxyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjNGFkZTgwJyA6ICcjMjJjNTVlJzsgLy8gR3JlZW4gbGluZSBmb3IgV1BNXHJcbiAgICBjdHgubGluZVdpZHRoID0gMjtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGRhdGEuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nLmxlZnQgKyAocG9pbnQuc2Vjb25kIC8gbWF4U2Vjb25kcykgKiBkcmF3V2lkdGg7XHJcbiAgICAgIGNvbnN0IHkgPSBwYWRkaW5nLnRvcCArIGRyYXdIZWlnaHQgLSAocG9pbnQud3BtIC8gbWF4V1BNKSAqIGRyYXdIZWlnaHQ7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcclxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgIC8vIERyYXcgZXJyb3JzIGFzIHJlZCBkb3RzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZWY0NDQ0JyA6ICcjZGMyNjI2JzsgLy8gUmVkIGZvciBlcnJvcnNcclxuICAgIGRhdGEuZm9yRWFjaChwb2ludCA9PiB7XHJcbiAgICAgIGlmIChwb2ludC5lcnJvcnMgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgICBjb25zdCB5ID0gcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC0gKHBvaW50LndwbSAvIG1heFdQTSkgKiBkcmF3SGVpZ2h0O1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHgsIHksIDQsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEcmF3IGFjY3VyYWN5IGxpbmVcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lID09PSAnZGFyaycgPyAnIzYwYTVmYScgOiAnIzNiODJmNic7IC8vIEJsdWUgbGluZSBmb3IgYWNjdXJhY3lcclxuICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgZGF0YS5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgeCA9IHBhZGRpbmcubGVmdCArIChwb2ludC5zZWNvbmQgLyBtYXhTZWNvbmRzKSAqIGRyYXdXaWR0aDtcclxuICAgICAgY29uc3QgeSA9IHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAtIChwb2ludC5hY2N1cmFjeSAvIDEwMCkgKiBkcmF3SGVpZ2h0O1xyXG5cclxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAvLyBEcmF3IGF4aXMgbGFiZWxzXHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUgPT09ICdkYXJrJyA/ICcjZjhmYWZjJyA6ICcjMWUyOTNiJztcclxuICAgIGN0eC5mb250ID0gJ2JvbGQgMTJweCBzYW5zLXNlcmlmJztcclxuICAgIFxyXG4gICAgLy8gV1BNIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSgxNSwgcGFkZGluZy50b3AgKyBkcmF3SGVpZ2h0IC8gMik7XHJcbiAgICBjdHgucm90YXRlKC1NYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ1dQTScsIDAsIDApO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIFxyXG4gICAgLy8gQWNjdXJhY3kgbGFiZWxcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gMTUsIHBhZGRpbmcudG9wICsgZHJhd0hlaWdodCAvIDIpO1xyXG4gICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMik7XHJcbiAgICBjdHguZmlsbFRleHQoJ0FjY3VyYWN5JywgMCwgMCk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgXHJcbiAgICAvLyBUaW1lIGxhYmVsXHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBjdHguZmlsbFRleHQoJ1RpbWUgKHNlY29uZHMpJywgcGFkZGluZy5sZWZ0ICsgZHJhd1dpZHRoIC8gMiwgaGVpZ2h0IC0gNSk7XHJcblxyXG4gIH0sIFtkYXRhLCB3aWR0aCwgaGVpZ2h0LCBtYXhXUE0sIG1heEVycm9ycywgdGhlbWUsIG1heFNlY29uZHNdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxjYW52YXMgXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfSBcclxuICAgICAgd2lkdGg9e3dpZHRofSBcclxuICAgICAgaGVpZ2h0PXtoZWlnaHR9IFxyXG4gICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLW1kIG14LWF1dG9cIlxyXG4gICAgLz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVzdWx0c0dyYXBoO1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJSZXN1bHRzR3JhcGgiLCJkYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJ0aGVtZSIsImNhbnZhc1JlZiIsImxlbmd0aCIsImRpdiIsInN0eWxlIiwiY2xhc3NOYW1lIiwicCIsIm1heFNlY29uZHMiLCJNYXRoIiwibWF4IiwibWFwIiwicG9pbnQiLCJzZWNvbmQiLCJtYXhXUE0iLCJ3cG0iLCJtYXhFcnJvcnMiLCJlcnJvcnMiLCJjdXJyZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsInBhZGRpbmciLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJkcmF3V2lkdGgiLCJkcmF3SGVpZ2h0IiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0aXRsZUNvbG9yIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwibGVnZW5kWSIsImxlZ2VuZFgiLCJzdHJva2VTdHlsZSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImFyYyIsIlBJIiwiZmlsbCIsImxpbmVXaWR0aCIsIndwbVN0ZXAiLCJjZWlsIiwiaSIsIndwbVZhbHVlIiwieSIsImFjY3VyYWN5VmFsdWUiLCJ0aW1lSW50ZXJ2YWwiLCJ4IiwiZm9yRWFjaCIsImluZGV4IiwiYWNjdXJhY3kiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVzdG9yZSIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/ResultsGraph.tsx\n"));

/***/ })

});